/**
 * Adobe Express Integration Service
 * 
 * Wrapper around Adobe Express SDK for executing fix commands dynamically.
 * NO HARDCODED VALUES - all commands come from backend API.
 */

export interface FixCommand {
  action: string;
  elementId: string;
  updates: Record<string, any>;
  metadata?: {
    fixId?: string;
    fixType?: string;
    previousValue?: string;
    newValue?: string;
    reason?: string;
  };
}

/**
 * Execute fix commands on Adobe Express canvas
 * Commands are generated dynamically from backend API (not hardcoded)
 */
export async function executeFixCommands(
  commands: FixCommand[],
  sandboxProxy: any // DocumentSandboxApi
): Promise<void> {
  if (!commands || commands.length === 0) {
    console.warn('No commands to execute');
    return;
  }

  // Execute each command sequentially
  for (const command of commands) {
    try {
      await executeCommand(command, sandboxProxy);
    } catch (error) {
      console.error(`Error executing command for element ${command.elementId}:`, error);
      // Continue with next command even if one fails
    }
  }
}

/**
 * Execute a single command
 * @private
 */
async function executeCommand(command: FixCommand, sandboxProxy: any): Promise<void> {
  switch (command.action) {
    case 'updateElement':
      await updateElement(command, sandboxProxy);
      break;
    
    default:
      console.warn(`Unknown command action: ${command.action}`);
  }
}

/**
 * Update an element's properties
 * All values come from command.updates (generated by backend from database)
 */
async function updateElement(command: FixCommand, sandboxProxy: any): Promise<void> {
  // Get design data to find the element
  const design = await sandboxProxy.getDesign();
  const layer = design.layers?.find((l: any) => l.id === command.elementId);

  if (!layer) {
    throw new Error(`Element ${command.elementId} not found in design`);
  }

  // Apply updates dynamically - values from database via backend API
  // We need to update via sandbox API
  // Since we're in the UI context, we need to pass commands to sandbox
  
  // Create updated design with modifications
  const updatedLayers = design.layers.map((l: any) => {
    if (l.id === command.elementId) {
      // Merge updates from command (values from database)
      return {
        ...l,
        ...command.updates, // All values from database via fix.recommendedValue
      };
    }
    return l;
  });

  // Set updated design
  await sandboxProxy.setDesign({
    layers: updatedLayers,
    canvas: design.canvas,
  });
}

/**
 * Generate preview of changes before applying
 */
export async function previewFixCommand(
  command: FixCommand,
  design: any
): Promise<any> {
  const layer = design.layers?.find((l: any) => l.id === command.elementId);

  if (!layer) {
    return null;
  }

  // Return preview of what will change
  const preview = {
    elementId: command.elementId,
    before: { ...layer },
    after: {
      ...layer,
      ...command.updates, // Values from database
    },
    changes: Object.keys(command.updates),
  };

  return preview;
}

/**
 * Batch execute commands with preview
 */
export async function executeBatchCommands(
  commands: FixCommand[],
  sandboxProxy: any,
  preview: boolean = false
): Promise<any[]> {
  if (preview) {
    const design = await sandboxProxy.getDesign();
    return commands.map((cmd) => previewFixCommand(cmd, design));
  }

  await executeFixCommands(commands, sandboxProxy);
  return [];
}
